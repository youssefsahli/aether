    <!DOCTYPE html>
    <html lang="en">

    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
        <meta name="apple-mobile-web-app-capable" content="yes">
        <meta name="theme-color" content="#1e1e2e">
        <meta name="description" content="A powerful, modern code editor with live preview, themes, and OPFS storage">
        <title>Aether v3 - Ace Flux</title>

        <!-- PWA Manifest & Icon -->
        <link rel="manifest" href="/manifest.json">
        <link rel="icon" type="image/svg+xml" href="/favicon.svg">
        <link rel="apple-touch-icon" href="/favicon.svg">

        <script src="https://unpkg.com/prettier@2.8.8/standalone.js"></script>
        <script src="https://unpkg.com/prettier@2.8.8/parser-babel.js"></script>
        <script src="https://unpkg.com/prettier@2.8.8/parser-html.js"></script>

        <!-- Ace Editor -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.32.7/ace.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.32.7/ext-language_tools.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.32.7/mode-javascript.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.32.7/mode-python.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.32.7/mode-pascal.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.32.7/mode-html.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.32.7/mode-css.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.32.7/mode-markdown.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.32.7/theme-tomorrow_night_eighties.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.32.7/theme-chrome.min.js"></script>

        <!-- Markdown Parser -->
        <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

        <!-- Commands List -->
        <script src="filesys/commands.js"></script>

        <!-- Icon Library -->
        <script src="filesys/icons.js"></script>
        <link rel="stylesheet" href="filesys/styles.css">
    </head>

    <body data-theme="mocha">

        <header>
            <button class="btn" onclick="App.toggleSidebar('left')" title="Toggle Sidebar" data-icon="menu"></button>
            <div class="logo">
                <span style="font-size: 20px; font-weight: 700; color: var(--accent); font-family: var(--font-code);">Æ</span>
                <span>AETHER</span>
            </div>

            <div class="toolbar">
                <div class="theme-swatches">
                    <div class="theme-swatch swatch-latte" onclick="Config.setTheme('latte')" title="Latte"></div>
                    <div class="theme-swatch swatch-frappe" onclick="Config.setTheme('frappe')" title="Frappe"></div>
                    <div class="theme-swatch swatch-macchiato" onclick="Config.setTheme('macchiato')" title="Macchiato">
                    </div>
                    <div class="theme-swatch swatch-mocha" onclick="Config.setTheme('mocha')" title="Mocha"></div>
                </div>
                <div style="width:1px; height:16px; background:var(--border); margin:0 8px;"></div>
                <button class="btn" onclick="Commands.trigger('openFile')" title="Open File (Ctrl+O)" data-icon="openFile"></button>
                <button class="btn" onclick="Commands.trigger('newFile')" title="New File (Alt+N)" data-icon="newFile"></button>
                <button class="btn" onclick="Commands.trigger('saveFile')" title="Save (Ctrl+S)" data-icon="save"></button>
                <div style="width:1px; height:16px; background:var(--border); margin:0 8px;"></div>
                <button id="nav-back-btn" class="btn" onclick="App.goBack()" title="Back (Alt+Left)" disabled data-icon="back"></button>
                <button id="nav-forward-btn" class="btn" onclick="App.goForward()" title="Forward (Alt+Right)" disabled data-icon="forward"></button>
                <div style="width:1px; height:16px; background:var(--border); margin:0 8px;"></div>
                <button class="btn primary" onclick="Commands.trigger('togglePreview')" title="Preview" data-icon="preview"></button>
                <button class="btn" onclick="App.toggleSidebar('right')" title="Outline" data-icon="outline"></button>
                <button class="btn" onclick="Commands.showPalette()" title="Commands (F1)" data-icon="commands"></button>
            </div>
        </header>

        <div id="app-shell">
            <aside id="sidebar-left">
                <div class="side-header" style="margin-top:8px;">
                    <span>Workspace</span>
                    <div style="display:flex; gap:4px;">
                        <button class="btn" onclick="TreeSearch.collapseAll('file-tree')" title="Collapse All"></button>
                        <button class="btn" onclick="FileSys.createWorkspaceDir()" title="New Directory"></button>
                        <button class="btn" onclick="FileSys.openFolder()" title="Open Folder"></button>
                    </div>
                </div>
                <div class="tree-search-container">
                    <input type="text" id="file-tree-search" class="tree-search" placeholder="Search files..." onkeyup="TreeSearch.filterTree('file-tree', this.value)">
                </div>
                <div id="file-tree" class="file-tree"></div>

                <div class="side-header" style="border-top:1px solid var(--border); padding-top:8px; margin-top:8px;">
                    <span id="opfs-header">Local Storage</span>
                    <div style="display:flex; gap:4px;">
                        <button class="btn" onclick="TreeSearch.collapseAll('opfs-tree')" title="Collapse All"></button>
                        <button class="btn" onclick="FileSys.createOPFSDir()" title="New Directory"></button>
                        <button class="btn" onclick="FileSys.createOPFSFile()" title="New Local File"></button>
                    </div>
                </div>
                <div class="tree-search-container">
                    <input type="text" id="opfs-tree-search" class="tree-search" placeholder="Search files..." onkeyup="TreeSearch.filterTree('opfs-tree', this.value)">
                </div>
                <div id="opfs-tree" class="file-tree" style="max-height: 250px;"></div>

                <div class="side-header" style="border-top:1px solid var(--border); padding-top:8px; margin-top:8px;">
                    <span>System Files</span>
                </div>
                <div class="tree-search-container">
                    <input type="text" id="system-tree-search" class="tree-search" placeholder="Search files..." onkeyup="TreeSearch.filterTree('system-tree', this.value)">
                </div>
                <div id="system-tree" class="file-tree" style="max-height: 250px;"></div>
            </aside>

            <main>
                <div id="tabs-scroll"></div>
                <div class="breadcrumbs">
                    <span>root</span><span>/</span><span id="bc-filename" style="color:var(--text)">[No Selection]</span>
                </div>

                <div id="editor-row">
                    <div id="editor-split">
                        <div id="code-stage"></div>
                        <div id="resizer"></div>

                        <div id="preview-pane">
                            <div class="preview-header" id="preview-header">
                                <span style="font-size:10px; font-weight:700; color:var(--text-dim);">PREVIEW</span>
                                <button class="btn" style="width:20px; height:20px;"
                                    onclick="Commands.trigger('togglePreview')">
                                    ✕
                                </button>
                            </div>
                            <iframe id="preview-frame"
                                sandbox="allow-scripts allow-modals allow-forms allow-same-origin"></iframe>
                            <div id="console-pane"
                                style="height: 150px; border-top: 1px solid var(--border); background: var(--header-bg); display: flex; flex-direction: column;">
                                <div class="console-header" style="display:flex; align-items:center; justify-content:space-between; padding:6px 8px; border-bottom:1px solid var(--border);">
                                    <span style="font-size:11px; font-weight:700; color:var(--text-dim);">CONSOLE</span>
                                    <div style="display:flex; gap:6px;">
                                        <button id="console-toggle-btn" class="btn" style="width:auto; padding:6px 8px; font-size:12px;" title="Collapse Console" onclick="UI.toggleConsole()">
                                            ▼
                                        </button>
                                        <button id="console-run-btn" class="btn" style="width:auto; padding:6px 8px; font-size:12px;" title="Run JS" onclick="App.runActiveJS()" hidden>
                                            ▶
                                        </button>
                                        <button id="console-clear-btn" class="btn" style="width:auto; padding:6px 8px; font-size:12px;" title="Clear Console" onclick="UI.clearConsole()">
                                            ✕
                                        </button>
                                    </div>
                                </div>
                                <div id="console-logs"
                                    style="flex:1; overflow-y: auto; padding: 8px; font-family: var(--font-code); font-size: 11px; color:var(--text);">
                                </div>
                            </div>
                            <div id="float-resizer"></div>
                        </div>
                    </div>

                    <aside id="sidebar-right" class="collapsed">
                        <div class="side-header" style="margin-top:8px;"><span>Outline</span></div>
                        <div class="outline-search">
                            <input id="outline-filter" placeholder="Filter symbols..." aria-label="Outline filter">
                        </div>
                        <div id="symbol-tree" class="file-tree"></div>
                    </aside>
                </div>
            </main>
        </div>

        <footer>
            <div class="stat-group">
                <span class="stat-highlight">ACE FLUX</span>
                <span style="opacity:0.3">|</span>
                <span class="stat-box" id="stat-file">--</span>
            </div>
            <div class="stat-group">
                <span class="stat-box" id="stat-lang">TXT</span>
                <span class="stat-box" id="stat-pos">1:1</span>
                <span class="stat-box" id="stat-indent">Space: 4</span>
            </div>
        </footer>

        <div id="palette-mask" class="overlay-mask" onclick="if(event.target===this) Commands.hidePalette()">
            <div class="dialog">
                <input type="text" id="cmd-input" placeholder="> Type a command..." autocomplete="off">
                <div id="cmd-list" style="max-height: 350px; overflow-y: auto;"></div>
            </div>
        </div>

        <div id="prompt-mask" class="overlay-mask">
            <div class="dialog">
                <div style="padding:14px 20px; font-weight:700; background:var(--header-bg); color:var(--text); border-bottom:1px solid var(--border); font-size:12px; text-transform:uppercase;"
                    id="prompt-msg">Input</div>
                <input type="text" id="prompt-input" autocomplete="off" style="background:var(--bg)">
                <div style="display:flex; padding:12px; gap:8px; background: var(--header-bg); justify-content: flex-end;">
                    <button class="btn" style="width:auto; padding:6px 12px; font-size:12px;"
                        onclick="Prompt.close()">Cancel</button>
                    <button class="btn primary" style="width:auto; padding:6px 12px; font-size:12px;"
                        id="prompt-ok">Submit</button>
                </div>
            </div>
        </div>

        <div id="confirm-mask" class="overlay-mask">
            <div class="dialog">
                <div style="padding:14px 20px; font-weight:700; background:var(--header-bg); color:var(--text); border-bottom:1px solid var(--border); font-size:12px; text-transform:uppercase;"
                    id="confirm-title">Confirmation</div>
                <div style="padding:20px 20px; color:var(--text); font-size:13px;" id="confirm-msg">Are you sure?</div>
                <div style="display:flex; padding:12px; gap:8px; background: var(--header-bg); justify-content: flex-end;">
                    <button class="btn" style="width:auto; padding:6px 12px; font-size:12px;"
                        onclick="Confirm.close()">Cancel</button>
                    <button class="btn primary" style="width:auto; padding:6px 12px; font-size:12px; color:#ff8888;"
                        id="confirm-ok">Confirm</button>
                </div>
            </div>
        </div>

        <div id="toast">
            ✓
            <span id="toast-msg">Initialized</span>
        </div>

        <script>
            /**
            * AETHER v3 - Final Polish + Persistence + Floating Preview + Symbols + Resizing
            */

            const DB = {
                db: null,
                async init() {
                    return new Promise((resolve, reject) => {
                        const req = indexedDB.open('AetherDB', 2);
                        req.onupgradeneeded = (e) => {
                            const db = e.target.result;
                            if (!db.objectStoreNames.contains('handles')) db.createObjectStore('handles');
                            if (!db.objectStoreNames.contains('session')) db.createObjectStore('session', { keyPath: 'id' });
                        };
                        req.onsuccess = (e) => { this.db = e.target.result; resolve(); };
                        req.onerror = reject;
                    });
                },
                async set(store, key, val) {
                    if (!this.db) return;
                    return new Promise((resolve) => {
                        const tx = this.db.transaction(store, 'readwrite');
                        if (store === 'session') tx.objectStore(store).put(val);
                        else tx.objectStore(store).put(val, key);
                        tx.oncomplete = resolve;
                    });
                },
                async get(store, key) {
                    if (!this.db) return null;
                    return new Promise((resolve) => {
                        const tx = this.db.transaction(store, 'readonly');
                        const req = tx.objectStore(store).get(key);
                        req.onsuccess = () => resolve(req.result);
                    });
                },
                async getAll(store) {
                    if (!this.db) return [];
                    return new Promise((resolve) => {
                        const tx = this.db.transaction(store, 'readonly');
                        const req = tx.objectStore(store).getAll();
                        req.onsuccess = () => resolve(req.result);
                    });
                },
                async clear(store) {
                    if (!this.db) return;
                    return new Promise(r => {
                        const tx = this.db.transaction(store, 'readwrite');
                        tx.objectStore(store).clear();
                        tx.oncomplete = r;
                    });
                }
            };

            const Config = {
                defaults: { theme: 'mocha', fontSize: 13, sidebarWidth: 220, wordWrap: true, previewType: 'split' },
                state: {},
                async initFromOPFS() {
                    // Try to load config defaults from OPFS if available
                    try {
                        if (!Store.state.opfsRoot) return null;
                        const configHandle = await Store.state.opfsRoot.getFileHandle('.aether.json').catch(() => null);
                        if (configHandle) {
                            const file = await configHandle.getFile();
                            const text = await file.text();
                            return JSON.parse(text);
                        }
                    } catch (e) { /* ignore */ }
                    return null;
                },
                async init() {
                    try {
                        // Load from OPFS first, then localStorage, then defaults
                        const opfsConfig = await this.initFromOPFS();
                        const localConfig = JSON.parse(localStorage.getItem('aether_config') || '{}');
                        this.state = { ...this.defaults, ...opfsConfig, ...localConfig };
                    }
                    catch (e) { this.state = { ...this.defaults }; }
                    this.apply();
                },
                save() { localStorage.setItem('aether_config', JSON.stringify(this.state)); this.apply(); },
                async saveToOPFS() {
                    // Save current config to OPFS as .aether.json
                    try {
                        if (!Store.state.opfsRoot) return false;
                        const handle = await Store.state.opfsRoot.getFileHandle('.aether.json', { create: true });
                        const writable = await handle.createWritable();
                        await writable.write(JSON.stringify(this.state, null, 2));
                        await writable.close();
                        UI.toast('Config saved to OPFS');
                        return true;
                    } catch (e) { UI.toast('Failed to save config to OPFS'); return false; }
                },
                setTheme(name) { this.state.theme = name; this.save(); },
                toggleWrap() { this.state.wordWrap = !this.state.wordWrap; this.save(); UI.toast(`Word Wrap: ${this.state.wordWrap ? 'ON' : 'OFF'}`); },
                togglePreviewType() {
                    this.state.previewType = this.state.previewType === 'split' ? 'float' : 'split';
                    this.save();
                    UI.toast(`Preview: ${this.state.previewType.toUpperCase()}`);
                },
                zoom(delta) { this.state.fontSize = Math.max(10, Math.min(24, this.state.fontSize + delta)); this.save(); UI.toast(`Zoom: ${this.state.fontSize}px`); },
                apply() {
                    document.body.setAttribute('data-theme', this.state.theme);
                    document.documentElement.style.setProperty('--sidebar-w', this.state.sidebarWidth + 'px');
                    const split = document.getElementById('editor-split');
                    if (this.state.previewType === 'float') split.classList.add('mode-float'); else split.classList.remove('mode-float');

                    if (Editor.instance) {
                        Editor.instance.setFontSize(this.state.fontSize);
                        Editor.instance.setOption("wrap", this.state.wordWrap);
                        Editor.instance.setTheme(this.state.theme === 'latte' ? 'ace/theme/chrome' : 'ace/theme/tomorrow_night_eighties');
                        Editor.instance.resize();
                    }
                }
            };

            const Script = {
                // Global scripting API exposed to user scripts
                context: {
                    // File/Buffer operations
                    openFile: (name, content) => {
                        const handle = undefined;
                        const kind = 'memory';
                        const existing = Store.state.buffers.find(b => b.name === name);
                        if (existing) return Store.setActive(existing.id);
                        Store.addBuffer({ id: 'b' + Date.now(), name, content, handle, kind, dirty: false });
                        return { name, id: Store.state.buffers[Store.state.buffers.length - 1].id };
                    },
                    newFile: (name = 'untitled.js', content = '') => Script.context.openFile(name, content),
                    getBuffer: (id) => {
                        if (!id && !Store.activeBuffer) return null;
                        return id ? Store.state.buffers.find(b => b.id === id) : Store.activeBuffer;
                    },
                    closeBuffer: (id) => Store.closeBuffer(id || Store.state.activeId),
                    setActiveBuffer: (id) => Store.setActive(id),
                    getActiveBuffer: () => Store.activeBuffer,
                    getAllBuffers: () => [...Store.state.buffers],
                    
                    // Editor operations
                    getEditorContent: () => Editor.instance ? Editor.instance.getValue() : '',
                    setEditorContent: (content) => { if (Editor.instance) Editor.instance.setValue(content, -1); },
                    getEditorLanguage: () => {
                        const buf = Store.activeBuffer;
                        return buf ? buf.name.split('.').pop().toLowerCase() : 'text';
                    },
                    getCursorPosition: () => Editor.instance ? Editor.instance.getCursorPosition() : { row: 0, column: 0 },
                    setCursorPosition: (row, column) => {
                        if (Editor.instance) Editor.instance.getSession().setScrollTop(0);
                        if (Editor.instance) Editor.instance.moveCursorToPosition({ row, column });
                    },
                    getSelectedText: () => Editor.instance ? Editor.instance.getSelectedText() : '',
                    insertText: (text) => { if (Editor.instance) Editor.instance.insert(text); },
                    
                    // Configuration
                    getConfig: () => ({ ...Config.state }),
                    setConfig: (key, value) => {
                        if (key && value !== undefined) {
                            Config.state[key] = value;
                            Config.save();
                            return true;
                        }
                        return false;
                    },
                    updateTheme: (name) => Config.setTheme(name),
                    updateZoom: (delta) => Config.zoom(delta),
                    
                    // UI operations
                    toast: (msg, duration = 2000) => UI.toast(msg),
                    log: (msg) => console.log(msg),
                    warn: (msg) => console.warn(msg),
                    error: (msg) => console.error(msg),
                    
                    // OPFS operations
                    saveOPFSFile: async (filename, content) => {
                        try {
                            if (!Store.state.opfsRoot) throw new Error('OPFS not available');
                            const handle = await Store.state.opfsRoot.getFileHandle(filename, { create: true });
                            const writable = await handle.createWritable();
                            await writable.write(content);
                            await writable.close();
                            Script.context.toast(`Saved: ${filename}`);
                            return true;
                        } catch (e) {
                            Script.context.error(`OPFS save failed: ${e.message}`);
                            return false;
                        }
                    },
                    readOPFSFile: async (filename) => {
                        try {
                            if (!Store.state.opfsRoot) throw new Error('OPFS not available');
                            const handle = await Store.state.opfsRoot.getFileHandle(filename);
                            const file = await handle.getFile();
                            return await file.text();
                        } catch (e) {
                            Script.context.error(`OPFS read failed: ${e.message}`);
                            return null;
                        }
                    },
                    listOPFSFiles: async () => {
                        try {
                            if (!Store.state.opfsRoot) return [];
                            const files = [];
                            for await (const [name, handle] of Store.state.opfsRoot.entries()) {
                                if (handle.kind === 'file') files.push(name);
                            }
                            return files;
                        } catch (e) { return []; }
                    },
                    deleteOPFSFile: async (filename) => {
                        try {
                            if (!Store.state.opfsRoot) throw new Error('OPFS not available');
                            await Store.state.opfsRoot.removeEntry(filename);
                            Script.context.toast(`Deleted: ${filename}`);
                            return true;
                        } catch (e) {
                            Script.context.error(`OPFS delete failed: ${e.message}`);
                            return false;
                        }
                    }
                },
                
                async loadScript(filename) {
                    try {
                        if (!Store.state.opfsRoot) return false;
                        const handle = await Store.state.opfsRoot.getFileHandle(filename).catch(() => null);
                        if (!handle) return false;
                        const file = await handle.getFile();
                        const code = await file.text();
                        return { code, handle };
                    } catch (e) { return false; }
                },
                
                async executeScript(code, context = this.context) {
                    try {
                        // Use AsyncFunction constructor - true async function with top-level await
                        const AsyncFunc = (async function(){}).constructor;
                        const fn = new AsyncFunc('Aether', code);
                        // Execute with context as both 'this' and as Aether parameter
                        await fn.apply(context, [context]);
                        return true;
                    } catch (e) {
                        console.error('Script full error:', e);
                        const msg = (e && e.message) ? String(e.message).slice(0, 200) : String(e).slice(0, 200);
                        try { 
                            UI.toast(`Script error: ${msg}`); 
                        } catch (err) { 
                            console.error('Toast error:', err);
                        }
                        return false;
                    }
                },
                
                async runInitScript() {
                    // Try to load and execute .aether.js from OPFS if available
                    try {
                        const script = await this.loadScript('.aether.js');
                        if (script && script.code) {
                            await this.executeScript(script.code);
                            UI.toast('Init script executed');
                        }
                    } catch (e) { /* silently ignore if no init script */ }
                }
            };

            const Store = {
                state: { buffers: [], activeId: null, opfsRoot: null, previewMode: false, consoleCollapsed: false, navHistory: [], navIndex: -1 },
                get activeBuffer() { return this.state.buffers.find(b => b.id === this.state.activeId); },
                addBuffer(b) { this.state.buffers.push(b); this.setActive(b.id); App.saveSession(); },
                closeBuffer(id) {
                    const idx = this.state.buffers.findIndex(b => b.id === id);
                    if (idx === -1) return;
                    this.state.buffers.splice(idx, 1);
                    if (this.state.activeId === id) {
                        const next = this.state.buffers[idx] || this.state.buffers[idx - 1];
                        this.setActive(next ? next.id : null);
                    } else UI.renderTabs();
                    App.saveSession();
                    // Update console header (show run button for .js files)
                    try { UI.updateConsoleHeader(); } catch (e) {}
                },
                setActive(id) {
                    if (this.state.activeId === id) return; // No change needed
                    this.state.activeId = id; UI.renderTabs();
                    const buf = this.activeBuffer;
                    if (buf) {
                        Editor.load(buf.content, buf.name);
                        document.getElementById('bc-filename').innerText = buf.name;
                    }
                    else { Editor.load('', 'txt'); document.getElementById('bc-filename').innerText = '[No Selection]'; }
                    // Track navigation history
                    if (this.state.navIndex < this.state.navHistory.length - 1) {
                        this.state.navHistory = this.state.navHistory.slice(0, this.state.navIndex + 1);
                    }
                    this.state.navHistory.push(id);
                    this.state.navIndex = this.state.navHistory.length - 1;
                    App.updateNavButtons();
                    App.saveSession();
                },
                updateContent(id, c) {
                    const b = this.state.buffers.find(b => b.id === id);
                    if (b && !b.readonly && b.content !== c) {
                        b.content = c;
                        if (!b.dirty) { b.dirty = true; UI.renderTabs(); }
                        App.debounceSaveBuffer(b);
                    }
                },
                markSaved(id) {
                    const b = this.state.buffers.find(b => b.id === id);
                    if (b) { b.dirty = false; UI.renderTabs(); App.saveBuffer(b); }
                }
            };

            const Symbols = {
                patterns: {
                    js: [
                        { r: /function\s+([a-zA-Z0-9_$]+)/g, icon: 'f', k: 'func' },
                        { r: /class\s+([a-zA-Z0-9_$]+)/g, icon: 'c', k: 'class' },
                        { r: /(?:const|let|var)\s+([a-zA-Z0-9_$]+)\s*=\s*(?:async\s*)?(?:function|\(.*?\)\s*=>)/g, icon: 'v', k: 'var' }
                    ],
                    pas: [
                        { r: /(?:procedure|function)\s+([A-Za-z0-9_]+)/ig, icon: 'f', k: 'func' },
                        { r: /type\s+([A-Za-z0-9_]+)/ig, icon: 't', k: 'type' },
                        { r: /\bvar\s+([A-Za-z0-9_]+)/ig, icon: 'v', k: 'var' }
                    ],
                    py: [
                        { r: /def\s+([a-zA-Z0-9_]+)/g, icon: 'f', k: 'func' },
                        { r: /class\s+([a-zA-Z0-9_]+)/g, icon: 'c', k: 'class' }
                    ],
                    css: [
                        { r: /([.#][a-zA-Z0-9_-]+)\s*\{/g, icon: '#', k: 'sel' }
                    ],
                    md: [
                        { r: /^(#{1,6})\s+(.*)$/gm, icon: 'H', k: 'head' }
                    ]
                },
                parse() {
                    const buf = Store.activeBuffer;
                    const tree = document.getElementById('symbol-tree');
                    if (!tree) return;
                    tree.innerHTML = '';
                    if (!buf) return;

                    const ext = buf.name.split('.').pop().toLowerCase();
                    let lang = null;
                    if (['js', 'ts', 'jsx'].includes(ext)) lang = 'js';
                    else if (ext === 'py') lang = 'py';
                    else if (ext === 'css') lang = 'css';
                    else if (ext === 'md') lang = 'md';
                    else if (ext === 'html' || ext === 'htm') lang = 'html';
                    else if (ext === 'pas' || ext === 'pp') lang = 'pas';
                    // If we don't know the lang but LSP provided symbols, continue; otherwise bail
                    if (!lang && !(window.Editor && Editor._lspSymbols && Editor._lspSymbols.length)) return;

                    const rules = this.patterns[lang] || [];
                    const groups = {}; // k -> {title, items:[]}

                    // Prefer LSP-provided symbols when available for any language
                    if (window.Editor && Editor._lspSymbols && Editor._lspSymbols.length) {
                        const seen = new Set();
                        Editor._lspSymbols.forEach(s => {
                            const kind = (s.kind || 'unknown');
                            let key = 'other'; let icon = '·';
                            if (/function|method|constructor|func/i.test(kind)) { key = 'func'; icon = 'f'; }
                            else if (/class/i.test(kind)) { key = 'class'; icon = 'c'; }
                            else if (/var|variable/i.test(kind)) { key = 'var'; icon = 'v'; }
                            else if (/import/i.test(kind)) { key = 'import'; icon = 'i'; }
                            else if (/heading/i.test(kind)) { key = 'head'; icon = 'H'; }
                            else if (/^id$/i.test(kind)) { key = 'id'; icon = '#'; }
                            else if (/^class$/i.test(kind)) { key = 'class'; icon = '.'; }
                            else if (/tag/i.test(kind)) { key = 'tag'; icon = 't'; }
                            if (!groups[key]) groups[key] = { title: key, items: [] };
                            const id = `${s.name}@${s.line||1}`;
                            if (!seen.has(id)) { groups[key].items.push({ name: s.name, line: s.line || 1, icon }); seen.add(id); }
                        });

                        // Merge regex fallback for JS to catch var-assigned functions or other patterns LSP might miss
                        if (lang === 'js') {
                            const lines = buf.content.split('\n');
                            lines.forEach((line, i) => {
                                rules.forEach(rule => {
                                    let match;
                                    rule.r.lastIndex = 0;
                                    while ((match = rule.r.exec(line)) !== null) {
                                        const name = match[1] || (rule.k === 'md' ? match[2] : '');
                                        const icon = rule.icon;
                                        const key = rule.k || String(icon);
                                        const id = `${name}@${i+1}`;
                                        if (!name || seen.has(id)) continue;
                                        if (!groups[key]) groups[key] = { title: key, items: [] };
                                        groups[key].items.push({ name, line: i + 1, icon });
                                        seen.add(id);
                                    }
                                });
                            });
                        }
                    } else {
                        if (lang === 'html') {
                            const txt = buf.content || '';
                            // headings
                            const reHeading = /<(h[1-6])\b[^>]*>([\s\S]*?)<\/\1>/ig;
                            let m;
                            while((m = reHeading.exec(txt)) !== null){
                                const idx = m.index || 0;
                                const line = txt.slice(0, idx).split('\n').length;
                                const title = (m[2] || '').replace(/\s+/g,' ').trim();
                                const key = 'head'; if (!groups[key]) groups[key] = { title: key, items: [] };
                                groups[key].items.push({ name: title || `<${m[1]}>`, line, icon: 'H' });
                            }
                            const reTag = /<([a-zA-Z0-9\-]+)([^>]*)>/g;
                            while((m = reTag.exec(txt)) !== null){
                                const tag = m[1]; const attrs = m[2] || ''; const idx = m.index || 0; const line = txt.slice(0, idx).split('\n').length;
                                const idMatch = /id\s*=\s*["']([^"']+)["']/i.exec(attrs);
                                if (idMatch){ const key='id'; if (!groups[key]) groups[key] = { title: key, items: [] }; groups[key].items.push({ name: `${tag}#${idMatch[1]}`, line, icon: '#' }); }
                                const classMatch = /class\s*=\s*["']([^"']+)["']/i.exec(attrs);
                                if (classMatch){ const classes = classMatch[1].split(/\s+/).filter(Boolean); for (const c of classes){ const key='class'; if (!groups[key]) groups[key] = { title: key, items: [] }; groups[key].items.push({ name: `${tag}.${c}`, line, icon: '.' }); } }
                                const srcMatch = /src\s*=\s*["']([^"']+)["']/i.exec(attrs);
                                if (srcMatch){ const key='import'; if (!groups[key]) groups[key] = { title: key, items: [] }; groups[key].items.push({ name: `${tag} src=${srcMatch[1]}`, line, icon: 'i' }); }
                            }
                        } else {
                            const lines = buf.content.split('\n');
                            lines.forEach((line, i) => {
                                rules.forEach(rule => {
                                    let match;
                                    rule.r.lastIndex = 0;
                                    while ((match = rule.r.exec(line)) !== null) {
                                        const name = lang === 'md' ? match[2] : match[1];
                                        const icon = lang === 'md' ? (match[1].length) : rule.icon;
                                        const key = rule.k || String(icon);
                                        if (!groups[key]) groups[key] = { title: key, items: [] };
                                        groups[key].items.push({ name, line: i + 1, icon });
                                    }
                                });
                            });
                        }
                    }

                    // Apply filter
                    const filterEl = document.getElementById('outline-filter');
                    const filter = filterEl && filterEl.value ? filterEl.value.trim().toLowerCase() : '';

                    Object.keys(groups).forEach((k) => {
                        const grp = groups[k];
                        const gEl = document.createElement('div'); gEl.className = 'symbol-group';

                        const header = document.createElement('div'); header.className = 'group-header';
                        const titleSpan = document.createElement('span');
                        titleSpan.textContent = `${grp.title.toUpperCase()} (${grp.items.length})`;
                        const chevronSpan = document.createElement('span');
                        chevronSpan.innerHTML = Icons.chevronDown;
                        chevronSpan.style.opacity = '0.7';
                        header.appendChild(titleSpan);
                        header.appendChild(chevronSpan);
                        header.onclick = () => {
                            gEl.classList.toggle('collapsed');
                            const collapsed = gEl.classList.contains('collapsed');
                            Store.state.outlineCollapsed = Store.state.outlineCollapsed || {};
                            Store.state.outlineCollapsed[k] = collapsed;
                            App.debounceSaveSession();
                        };
                        gEl.appendChild(header);

                        const itemsWrap = document.createElement('div'); itemsWrap.className = 'group-items';
                        grp.items.forEach(it => {
                            if (filter && !it.name.toLowerCase().includes(filter)) return;
                            const itEl = document.createElement('div'); itEl.className = 'symbol-item';
                            itEl.innerHTML = `<span class="symbol-kind">${it.icon}</span><span class="symbol-name">${it.name}</span><span class="symbol-line">${it.line}</span>`;
                            itEl.onclick = () => { try { Editor.instance.gotoLine(it.line); Editor.instance.focus(); } catch (e) {} };
                            itemsWrap.appendChild(itEl);
                        });

                        gEl.appendChild(itemsWrap);
                        // Apply collapsed state if present
                        if (Store.state.outlineCollapsed && Store.state.outlineCollapsed[k]) gEl.classList.add('collapsed');
                        tree.appendChild(gEl);
                    });
                }
            };

            const Editor = {
                instance: null,
                init() {
                        this.instance = ace.edit("code-stage");
                    this.instance.setOptions({
                        enableBasicAutocompletion: true, enableLiveAutocompletion: true,
                        showPrintMargin: false, useSoftTabs: true, tabSize: 4,
                        fontSize: Config.state.fontSize, fontFamily: 'JetBrains Mono, monospace', scrollPastEnd: 0.5
                    });
                    this.instance.on('change', () => {
                        if (Store.state.activeId) Store.updateContent(Store.state.activeId, this.instance.getValue());
                        App.debouncePreview();
                        this.debounceSymbols();
                        // send content to worker for analysis
                        try { if (this.lspWorker) { clearTimeout(this._lspTimer); this._lspTimer = setTimeout(()=> this.lspWorker.postMessage({ type: 'analyze', content: this.instance.getValue() }), 600); } } catch(e){}
                    });
                    this.instance.on('changeSelection', () => App.updateStats());
                    // Shortcuts
                    this.instance.commands.addCommand({ name: 'save', bindKey: { win: 'Ctrl-S', mac: 'Command-S' }, exec: () => Commands.trigger('saveFile') });
                    this.instance.commands.addCommand({ name: 'palette', bindKey: { win: 'F1|Ctrl-P', mac: 'F1|Command-P' }, exec: () => Commands.showPalette() });
                    this.instance.commands.addCommand({ name: 'new', bindKey: { win: 'Alt-N', mac: 'Option-N' }, exec: () => Commands.trigger('newFile') });
                    // Signature help command integrated with Ace so editor handles the shortcut
                    this.instance.commands.addCommand({ name: 'signatureHelp', bindKey: { win: 'Ctrl-I', mac: 'Command-I' }, exec: () => { try { this.showSignatureHelp(); } catch (e){} } });

                    // Initialize lightweight LSP worker and completer
                    try {
                        this.lspWorker = new Worker('lsp-worker.js');
                        this.lspWorker.addEventListener('message', (e) => {
                            const d = e.data;
                            if (!d) return;
                            if (d.type === 'analyze') {
                                // store symbols with locations and update outline
                                this._lspSymbols = d.symbols || [];
                                try { Symbols.parse(); } catch (e) {}
                            }
                            if (d.type === 'hover') {
                                if (!this._hoverTip) return;
                                const sig = d.signature;
                                const doc = d.doc;
                                const kind = d.kind || '';
                                if (!sig && !doc) { this._hoverTip.style.display = 'none'; return; }

                                // Build rich content safely
                                this._hoverTip.innerHTML = '';
                                const code = document.createElement('div');
                                code.style.fontFamily = 'JetBrains Mono, monospace';
                                code.style.fontSize = '12px';
                                code.style.fontWeight = '700';
                                code.style.marginBottom = '6px';
                                code.textContent = sig || `${kind}`;
                                this._hoverTip.appendChild(code);

                                if (doc) {
                                    const p = document.createElement('div');
                                    p.style.fontSize = '11px';
                                    p.style.opacity = '0.9';
                                    p.style.whiteSpace = 'pre-wrap';
                                    p.textContent = doc.replace(/^\s*\*\s?/mg, '').trim();
                                    this._hoverTip.appendChild(p);
                                }

                                const x = (this._lastMouse && this._lastMouse.x) || (window.innerWidth/2);
                                const y = (this._lastMouse && this._lastMouse.y) || (window.innerHeight/2);
                                this._hoverTip.style.left = (x + 12) + 'px';
                                this._hoverTip.style.top = (y + 12) + 'px';
                                this._hoverTip.style.display = 'block';
                            }
                        });

                        const completer = {
                            getCompletions: (editor, session, pos, prefix, callback) => {
                                if (!this.lspWorker) return callback(null, []);
                                const content = editor.getValue();
                                const id = 'c' + Date.now() + Math.random();
                                const handler = (ev) => {
                                    const m = ev.data;
                                    if (!m || m.type !== 'complete' || m.id !== id) return;
                                    const items = (m.items || []).map(i => ({ caption: i.caption, value: i.value, meta: i.meta }));
                                    callback(null, items);
                                    this.lspWorker.removeEventListener('message', handler);
                                };
                                this.lspWorker.addEventListener('message', handler);
                                this.lspWorker.postMessage({ type: 'complete', content, prefix, id });
                            }
                        };
                        this.instance.completers = (this.instance.completers || []).concat([completer]);
                        // Create hover tooltip element
                        try {
                            const tip = document.createElement('div');
                            tip.id = 'hover-tip';
                            const cs = getComputedStyle(document.body);
                            tip.style.position = 'fixed';
                            tip.style.display = 'none';
                            tip.style.padding = '6px 8px';
                            tip.style.background = cs.getPropertyValue('--header-bg') || '#222';
                            tip.style.color = cs.getPropertyValue('--text') || '#fff';
                            tip.style.border = `1px solid ${cs.getPropertyValue('--border') || '#333'}`;
                            tip.style.borderRadius = '6px';
                            tip.style.fontSize = '12px';
                            tip.style.zIndex = 9999;
                            tip.style.pointerEvents = 'none';
                            tip.style.fontFamily = 'JetBrains Mono, monospace';
                            document.body.appendChild(tip);
                            this._hoverTip = tip;
                            this._lastMouse = null;

                            let hoverTimer = null;
                            // Mouse move over editor, debounce and request hover info
                            this.instance.container.addEventListener('mousemove', (e) => {
                                clearTimeout(hoverTimer);
                                hoverTimer = setTimeout(() => {
                                    try {
                                        const pos = this.instance.renderer.screenToTextCoordinates(e.clientX, e.clientY);
                                        const token = this.instance.session.getTokenAt(pos.row, pos.column);
                                        if (!token) { this._hoverTip.style.display = 'none'; return; }
                                        const word = token.value;
                                        if (!/^[A-Za-z$_][A-Za-z0-9$_]*$/.test(word)) { this._hoverTip.style.display = 'none'; return; }
                                        this._lastMouse = { x: e.clientX, y: e.clientY };
                                        if (this.lspWorker) this.lspWorker.postMessage({ type: 'hover', word, content: this.instance.getValue() });
                                    } catch (err) { this._hoverTip.style.display = 'none'; }
                                }, 180);
                            });

                            this.instance.container.addEventListener('mouseleave', () => { if (this._hoverTip) this._hoverTip.style.display = 'none'; });
                            // Single-key shortcut: Ctrl/Cmd+I => signature help
                            try {
                                document.addEventListener('keydown', (e) => {
                                    if (!(e.ctrlKey || e.metaKey)) return;
                                    if (e.key.toLowerCase() === 'i') {
                                        e.preventDefault();
                                        try { this.showSignatureHelp(); } catch (err) { console.warn(err); }
                                    }
                                });
                            } catch (e) {}
                        } catch (e) { /* ignore hover initialization errors */ }
                    } catch (e) { console.warn('LSP worker not available', e); }
                },
                load(content, filename) {
                    if (this.instance.getValue() !== content) this.instance.setValue(content, -1);
                    const ext = filename ? filename.split('.').pop().toLowerCase() : 'txt';
                    const modes = { js: 'javascript', ts: 'javascript', html: 'html', css: 'css', py: 'python', md: 'markdown', json: 'javascript', pas: 'pascal', pp: 'pascal' };
                    this.instance.session.setMode(`ace/mode/${modes[ext] || 'text'}`);
                    this.instance.session.getUndoManager().reset();
                    App.updateStats(); App.debouncePreview(true);
                    // trigger LSP analyze for immediate symbol extraction, then parse
                    try { if (this.lspWorker) { clearTimeout(this._lspTimer); this._lspTimer = setTimeout(()=> this.lspWorker.postMessage({ type: 'analyze', content }), 150); } } catch(e){}
                    Symbols.parse();
                },
                showSignatureHelp() {
                    try {
                        const pos = this.instance.getCursorPosition();
                        // try to get a word range at the cursor (works even on whitespace near word)
                        const range = this.instance.session.getWordRange(pos.row, pos.column);
                        let word = null;
                        if (range) word = this.instance.session.getTextRange(range).trim();
                        if (!word) {
                            // fallback to token at column-1
                            const token = this.instance.session.getTokenAt(pos.row, Math.max(0, pos.column-1));
                            if (token && /^[A-Za-z$_][A-Za-z0-9$_]*$/.test(token.value)) word = token.value;
                        }
                        if (!word) return UI.toast('No symbol at cursor');

                        // compute screen coordinates for tooltip placement using renderer
                        let coords = null;
                        try { coords = this.instance.renderer.textToScreenCoordinates(pos.row, pos.column); } catch (e) { coords = null; }
                        if (coords) {
                            // pageX/pageY exist in modern ace builds; fallback to client + scroll
                            const x = ('pageX' in coords && coords.pageX) ? coords.pageX : (coords.left + window.pageXOffset);
                            const y = ('pageY' in coords && coords.pageY) ? coords.pageY : (coords.top + window.pageYOffset);
                            this._lastMouse = { x, y };
                        }

                        if (this.lspWorker) this.lspWorker.postMessage({ type: 'hover', word, content: this.instance.getValue() });
                    } catch (e) { console.warn('signature help failed', e); }
                },
                debounceSymbols() {
                    clearTimeout(this.symTimer);
                    this.symTimer = setTimeout(() => Symbols.parse(), 1000);
                }
            };

            // Fuzzy search and tree filtering utility
            const TreeSearch = {
                // Fuzzy match algorithm - returns score (higher is better match)
                fuzzyScore(searchStr, targetStr) {
                    if (!searchStr) return 100; // No search = perfect match
                    searchStr = searchStr.toLowerCase();
                    targetStr = targetStr.toLowerCase();
                    
                    if (targetStr.includes(searchStr)) return 90; // Substring match is great
                    
                    let score = 0;
                    let searchIdx = 0;
                    let lastMatchIdx = -1;
                    
                    for (let i = 0; i < targetStr.length && searchIdx < searchStr.length; i++) {
                        if (targetStr[i] === searchStr[searchIdx]) {
                            // Consecutive matches get bonus
                            const consecutiveBonus = (i === lastMatchIdx + 1) ? 10 : 0;
                            score += 10 + consecutiveBonus;
                            lastMatchIdx = i;
                            searchIdx++;
                        }
                    }
                    
                    return searchIdx === searchStr.length ? score : 0; // Only return score if all chars matched
                },
                
                // Collapse all directories in a tree (recursive - hides all descendants)
                collapseAll(treeId) {
                    const container = document.getElementById(treeId);
                    if (!container) return;
                    
                    const directories = container.querySelectorAll('[data-tree-type="directory"]');
                    directories.forEach(dir => {
                        dir.classList.add('collapsed');
                        // Hide all descendants recursively
                        const dirLevel = parseInt(dir.getAttribute('data-tree-level') || 0);
                        let next = dir.nextElementSibling;
                        while (next && parseInt(next.getAttribute('data-tree-level') || 0) > dirLevel) {
                            next.classList.add('hidden-by-parent');
                            next = next.nextElementSibling;
                        }
                    });
                },
                
                // Filter tree items based on search string
                filterTree(treeId, searchStr) {
                    const container = document.getElementById(treeId);
                    if (!container) return;
                    
                    const items = container.querySelectorAll('[data-tree-name]');
                    let hasVisibleItem = false;
                    
                    // First pass: score and filter items
                    items.forEach(item => {
                        const name = item.getAttribute('data-tree-name');
                        const score = this.fuzzyScore(searchStr, name);
                        
                        if (score > 0) {
                            item.classList.remove('hidden');
                            hasVisibleItem = true;
                            
                            // Show all parent directories
                            let parent = item.previousElementSibling;
                            while (parent) {
                                const parentLevel = parseInt(parent.getAttribute('data-tree-level') || 0);
                                const itemLevel = parseInt(item.getAttribute('data-tree-level') || 0);
                                
                                if (parentLevel < itemLevel && parent.classList.contains('is-directory')) {
                                    parent.classList.remove('hidden', 'collapsed', 'hidden-by-parent');
                                }
                                if (parentLevel === 0) break;
                                parent = parent.previousElementSibling;
                            }
                        } else {
                            item.classList.add('hidden');
                        }
                    });
                    
                    // Auto-expand relevant directories when searching
                    if (searchStr.length > 0) {
                        items.forEach(item => {
                            if (!item.classList.contains('hidden')) {
                                let prev = item.previousElementSibling;
                                while (prev) {
                                    const prevLevel = parseInt(prev.getAttribute('data-tree-level') || 0);
                                    const itemLevel = parseInt(item.getAttribute('data-tree-level') || 0);
                                    
                                    if (prevLevel < itemLevel && prev.classList.contains('is-directory')) {
                                        prev.classList.remove('collapsed', 'hidden-by-parent');
                                    }
                                    if (prevLevel === 0) break;
                                    prev = prev.previousElementSibling;
                                }
                            }
                        });
                    }
                }
            };

            const FileSys = {
                rootDir: null,
                async initOPFS() {
                    try {
                        if (!navigator.storage?.getDirectory) throw 1;
                        Store.state.opfsRoot = await navigator.storage.getDirectory();
                        this.renderOPFS();
                    } catch (e) { document.getElementById('opfs-header').innerText = "LocalStorage Only"; }
                },
                async renderOPFS(dirHandle = null, parentEl = null, level = 0) {
                    if (!Store.state.opfsRoot) return;
                    if (level === 0) {
                        parentEl = document.getElementById('opfs-tree');
                        parentEl.innerHTML = '';
                        dirHandle = Store.state.opfsRoot;
                    }
                    
                    for await (const [name, handle] of dirHandle.entries()) {
                        const el = document.createElement('div');
                        el.className = 'tree-item';
                        el.setAttribute('data-tree-name', name);
                        el.setAttribute('data-tree-level', level);
                        el.style.paddingLeft = `${(level * 10) + 12}px`;
                        
                        if (handle.kind === 'directory') {
                            // Directory
                            el.classList.add('is-directory');
                            el.setAttribute('data-tree-type', 'directory');
                            
                            // Add toggle
                            const toggle = document.createElement('span');
                            toggle.className = 'tree-item-toggle';
                            toggle.innerHTML = Icons.chevronDown;
                            toggle.onclick = (e) => {
                                e.stopPropagation();
                                const isCollapsed = el.classList.toggle('collapsed');
                                // Toggle visibility of children (only direct children when expanding)
                                const dirLevel = level;
                                const childLevel = level + 1;
                                let next = el.nextElementSibling;
                                while (next && parseInt(next.getAttribute('data-tree-level') || 0) > dirLevel) {
                                    if (isCollapsed) {
                                        next.classList.add('hidden-by-parent');
                                    } else if (parseInt(next.getAttribute('data-tree-level') || 0) === childLevel) {
                                        // Only show direct children when expanding
                                        next.classList.remove('hidden-by-parent');
                                    }
                                    next = next.nextElementSibling;
                                }
                            };
                            el.appendChild(toggle);
                            
                            // Content
                            const content = document.createElement('span');
                            content.className = 'tree-item-content';
                            const icon = document.createElement('span');
                            icon.innerHTML = Icons.folder;
                            icon.style.display = 'inline-flex';
                            const text = document.createElement('span');
                            text.textContent = name;
                            content.appendChild(icon);
                            content.appendChild(text);
                            el.appendChild(content);
                            
                            // Delete button for directory
                            const actions = document.createElement('div');
                            actions.className = 'tree-actions';
                            const delBtn = document.createElement('span');
                            delBtn.className = 'action-btn action-delete';
                            delBtn.title = 'Delete';
                            delBtn.innerHTML = Icons.trash;
                            delBtn.onclick = (e) => { e.stopPropagation(); this.deleteOPFSDir(name); };
                            actions.appendChild(delBtn);
                            el.appendChild(actions);
                            
                            parentEl.appendChild(el);
                            await this.renderOPFS(handle, parentEl, level + 1);
                        } else if (handle.kind === 'file') {
                            // File
                            el.classList.add('is-file');
                            el.setAttribute('data-tree-type', 'file');
                            
                            const content = document.createElement('span');
                            content.className = 'tree-item-content';
                            const icon = document.createElement('span');
                            icon.innerHTML = Icons.file;
                            icon.style.display = 'inline-flex';
                            const fileText = document.createElement('span');
                            fileText.textContent = name;
                            content.appendChild(icon);
                            content.appendChild(fileText);
                            content.onclick = async () => App.openBuffer(name, await (await handle.getFile()).text(), handle, 'opfs');
                            
                            const actions = document.createElement('div');
                            actions.className = 'tree-actions';
                            
                            const renBtn = document.createElement('span');
                            renBtn.className = 'action-btn'; renBtn.title = "Rename";
                            renBtn.innerHTML = Icons.edit;
                            renBtn.onclick = (e) => { e.stopPropagation(); this.renameOPFSFile(name, handle); };
                            
                            const delBtn = document.createElement('span');
                            delBtn.className = 'action-btn action-delete'; delBtn.title = "Delete";
                            delBtn.innerHTML = Icons.trash;
                            delBtn.onclick = (e) => { e.stopPropagation(); this.deleteOPFSFile(name); };
                            
                            actions.append(renBtn, delBtn);
                            el.append(content, actions);
                            parentEl.appendChild(el);
                        }
                    }
                },
                async createOPFSFile() {
                    Prompt.open("New Local File:", "script.js", async (name) => {
                        if (!name) return;
                        try {
                            const handle = await Store.state.opfsRoot.getFileHandle(name, { create: true });
                            App.openBuffer(name, "", handle, 'opfs');
                            this.renderOPFS();
                        } catch (e) { UI.toast('Error creating file'); }
                    });
                },
                async createOPFSDir() {
                    if (!Store.state.opfsRoot) {
                        UI.toast('Local Storage not available.');
                        return;
                    }
                    Prompt.open("New Directory Name:", "new-folder", async (name) => {
                        if (!name || name.trim() === '') return;
                        try {
                            await Store.state.opfsRoot.getDirectoryHandle(name.trim(), { create: true });
                            this.renderOPFS();
                            UI.toast(`Directory created: ${name}`);
                        } catch (e) { 
                            console.error('Error creating directory:', e);
                            UI.toast('Error: ' + (e.message || 'Could not create directory')); 
                        }
                    });
                },
                async createWorkspaceDir() {
                    if (!this.rootDir) {
                        UI.toast('No workspace open. Open a folder first.');
                        return;
                    }
                    Prompt.open("New Directory Name:", "new-folder", async (name) => {
                        if (!name || name.trim() === '') return;
                        try {
                            await this.rootDir.getDirectoryHandle(name.trim(), { create: true });
                            await this.renderWorkspace(this.rootDir);
                            UI.toast(`Directory created: ${name}`);
                        } catch (e) { 
                            console.error('Error creating directory:', e);
                            UI.toast('Error: ' + (e.message || 'Could not create directory')); 
                        }
                    });
                },
                async renameOPFSFile(oldName, handle) {
                    Prompt.open(`Rename "${oldName}" to:`, oldName, async (newName) => {
                        if (!newName || newName === oldName) return;
                        try {
                            const file = await handle.getFile();
                            const content = await file.text();
                            const newHandle = await Store.state.opfsRoot.getFileHandle(newName, { create: true });
                            const writable = await newHandle.createWritable();
                            await writable.write(content);
                            await writable.close();
                            await Store.state.opfsRoot.removeEntry(oldName);

                            const buf = Store.state.buffers.find(b => b.name === oldName && b.kind === 'opfs');
                            if (buf) { buf.name = newName; buf.handle = newHandle; UI.renderTabs(); document.getElementById('bc-filename').innerText = newName; }

                            this.renderOPFS(); UI.toast('Renamed');
                        } catch (e) { UI.toast('Rename Failed'); }
                    });
                },
                async deleteOPFSFile(name) {
                    Confirm.open("Delete File", `Permanently delete "${name}"?`, async () => {
                        try {
                            await Store.state.opfsRoot.removeEntry(name);
                            const buf = Store.state.buffers.find(b => b.name === name && b.kind === 'opfs');
                            if (buf) App.closeBuffer(buf.id);
                            this.renderOPFS(); UI.toast('Deleted');
                        } catch (e) { UI.toast('Delete failed'); }
                    });
                },
                async deleteWorkspaceDir(dirPath) {
                    Confirm.open("Delete Folder", `Permanently delete "${dirPath}" and all contents?`, async () => {
                        try {
                            const parts = dirPath.split('/');
                            let currentHandle = this.rootDir;
                            for (let i = 0; i < parts.length - 1; i++) {
                                currentHandle = await currentHandle.getDirectoryHandle(parts[i]);
                            }
                            await currentHandle.removeEntry(parts[parts.length - 1], { recursive: true });
                            await this.renderWorkspace(this.rootDir);
                            UI.toast('Folder deleted');
                        } catch (e) { 
                            console.error('Delete failed:', e);
                            UI.toast('Delete failed: ' + e.message); 
                        }
                    });
                },
                async deleteOPFSDir(name) {
                    Confirm.open("Delete Folder", `Permanently delete "${name}" and all contents?`, async () => {
                        try {
                            await Store.state.opfsRoot.removeEntry(name, { recursive: true });
                            this.renderOPFS();
                            UI.toast('Folder deleted');
                        } catch (e) { 
                            console.error('Delete failed:', e);
                            UI.toast('Delete failed: ' + e.message); 
                        }
                    });
                },
                async saveBuffer(buf) {
                    if (buf.name === 'config.json' && buf.kind === 'config') { Config.state = JSON.parse(buf.content); Config.save(); Store.markSaved(buf.id); return; }
                    try {
                        let handle = buf.handle;
                        if (!handle && buf.kind === 'memory') {
                            handle = await window.showSaveFilePicker({ suggestedName: buf.name });
                            buf.handle = handle; buf.kind = 'disk'; buf.name = handle.name;
                        }
                        const writable = await handle.createWritable();
                        await writable.write(buf.content);
                        await writable.close();
                        Store.markSaved(buf.id);
                        UI.toast(`Saved: ${buf.name}`);
                    } catch (e) { UI.toast('Save Cancelled'); }
                },
                async openFolder() {
                    try {
                        const handle = await window.showDirectoryPicker();
                        this.rootDir = handle;
                        await DB.set('handles', 'rootDir', handle);
                        this.renderWorkspace(handle);
                    } catch (e) { }
                },
                async openFile() {
                    try {
                        // Use the File System Access API to pick a single file
                        const [handle] = await window.showOpenFilePicker();
                        if (!handle) return;
                        const file = await handle.getFile();
                        const content = await file.text();
                        App.openBuffer(handle.name, content, handle, 'disk');
                    } catch (e) { UI.toast('Open cancelled'); }
                },
                async restoreRoot(handle) {
                    this.rootDir = handle;
                    if ((await handle.queryPermission({ mode: 'read' })) === 'granted') {
                        this.renderWorkspace(handle);
                    } else {
                        document.getElementById('file-tree').innerHTML = `<div class="reconnect-btn" onclick="FileSys.reconnectRoot()">Reconnect to /${handle.name}</div>`;
                    }
                },
                async reconnectRoot() {
                    if (this.rootDir && (await this.rootDir.requestPermission({ mode: 'read' })) === 'granted') {
                        this.renderWorkspace(this.rootDir);
                    }
                },
                async renderWorkspace(dirHandle, parentEl = document.getElementById('file-tree'), level = 0, parentPath = '') {
                    if (level === 0) parentEl.innerHTML = '';
                    for await (const [name, handle] of dirHandle.entries()) {
                        const currentPath = parentPath ? `${parentPath}/${name}` : name;
                        const el = document.createElement('div');
                        el.className = 'tree-item';
                        el.setAttribute('data-tree-name', name);
                        el.setAttribute('data-tree-path', currentPath);
                        el.setAttribute('data-tree-level', level);
                        el.style.paddingLeft = `${(level * 10) + 12}px`;
                        
                        if (handle.kind === 'directory') {
                            el.classList.add('is-directory');
                            el.setAttribute('data-tree-type', 'directory');
                            
                            // Add toggle for directory
                            const toggle = document.createElement('span');
                            toggle.className = 'tree-item-toggle';
                            toggle.innerHTML = Icons.chevronDown;
                            toggle.onclick = (e) => {
                                e.stopPropagation();
                                const isCollapsed = el.classList.toggle('collapsed');
                                // Toggle visibility of children (only direct children when expanding)
                                const dirLevel = level;
                                const childLevel = level + 1;
                                let next = el.nextElementSibling;
                                while (next && parseInt(next.getAttribute('data-tree-level') || 0) > dirLevel) {
                                    if (isCollapsed) {
                                        next.classList.add('hidden-by-parent');
                                    } else if (parseInt(next.getAttribute('data-tree-level') || 0) === childLevel) {
                                        // Only show direct children when expanding
                                        next.classList.remove('hidden-by-parent');
                                    }
                                    next = next.nextElementSibling;
                                }
                            };
                            el.appendChild(toggle);
                        } else {
                            el.classList.add('is-file');
                            el.setAttribute('data-tree-type', 'file');
                        }
                        
                        const content = document.createElement('span');
                        content.className = 'tree-item-content';
                        const icon = document.createElement('span');
                        icon.innerHTML = handle.kind === 'directory' ? Icons.folder : Icons.file;
                        icon.style.display = 'inline-flex';
                        const text = document.createElement('span');
                        text.textContent = name;
                        content.appendChild(icon);
                        content.appendChild(text);
                        el.appendChild(content);
                        
                        if (handle.kind === 'file') {
                            el.onclick = async () => App.openBuffer(name, await (await handle.getFile()).text(), handle, 'disk');
                        } else if (handle.kind === 'directory') {
                            // Add delete button for directories
                            const actions = document.createElement('div');
                            actions.className = 'tree-actions';
                            const delBtn = document.createElement('span');
                            delBtn.className = 'action-btn action-delete';
                            delBtn.title = 'Delete';
                            delBtn.innerHTML = Icons.trash;
                            delBtn.onclick = (e) => { e.stopPropagation(); this.deleteWorkspaceDir(currentPath); };
                            actions.appendChild(delBtn);
                            el.appendChild(actions);
                        }
                        
                        parentEl.appendChild(el);
                        if (handle.kind === 'directory') await this.renderWorkspace(handle, parentEl, level + 1, currentPath);
                    }
                }
            };

            // System filesystem - read-only lazy loading from workspace
            const SystemFS = {
                fileCache: new Map(),
                loadedFiles: new Set(),
                async init() {
                    await this.syncFromDocs();
                    await this.renderSystemTree();
                },
                async syncFromDocs() {
                    // Check if we have internet connectivity
                    try {
                        const response = await fetch('filesys/docs/welcome.md', { method: 'HEAD', cache: 'no-store' });
                        if (!response.ok) return; // No internet or filesys/docs not available
                    } catch (e) {
                        return; // No internet connection
                    }
                    
                    // List of docs to sync from filesys/docs
                    const docsToSync = ['welcome.md', 'manual.md', 'SCRIPTING.md', 'SCRIPT_QUICK_REF.md', 'MARKDOWN_NAVIGATION.md'];
                    
                    for (const filename of docsToSync) {
                        try {
                            const response = await fetch(`filesys/docs/${filename}`);
                            if (response.ok) {
                                const content = await response.text();
                                this.fileCache.set(filename, content);
                                this.loadedFiles.add(filename);
                            }
                        } catch (e) {
                            console.warn(`Could not sync ${filename}:`, e);
                        }
                    }
                },
                async renderSystemTree() {
                    const div = document.getElementById('system-tree');
                    if (!div) return;
                    div.innerHTML = '';
                    
                    // Organize files into folders
                    const docFiles = ['welcome.md', 'manual.md', 'SCRIPTING.md', 'SCRIPT_QUICK_REF.md', 'MARKDOWN_NAVIGATION.md', 'test-navigation.md'];
                    const configFiles = ['.aether.js', 'config.json', 'manifest.json'];
                    const otherFiles = ['EXAMPLE_SCRIPTS.js', 'LICENSE', 'CNAME', 'index.html'];
                    
                    // Create docs folder
                    const docsFolder = this.createSystemFolder('docs', div, 0);
                    for (const filename of docFiles) {
                        this.createSystemFile(filename, docsFolder, 1);
                    }
                    
                    // Create config folder
                    const configFolder = this.createSystemFolder('config', div, 0);
                    for (const filename of configFiles) {
                        this.createSystemFile(filename, configFolder, 1);
                    }
                    
                    // Add other files directly at root
                    for (const filename of otherFiles) {
                        this.createSystemFile(filename, div, 0);
                    }
                },
                createSystemFolder(name, parentEl, level) {
                    const el = document.createElement('div');
                    el.className = 'tree-item is-directory';
                    el.setAttribute('data-tree-name', name);
                    el.setAttribute('data-tree-level', level);
                    el.setAttribute('data-tree-type', 'directory');
                    el.style.paddingLeft = `${(level * 10) + 12}px`;
                    
                    // Toggle
                    const toggle = document.createElement('span');
                    toggle.className = 'tree-item-toggle';
                    toggle.innerHTML = Icons.chevronDown;
                    toggle.onclick = (e) => {
                        e.stopPropagation();
                        const isCollapsed = el.classList.toggle('collapsed');
                        // Toggle visibility of children (only direct children when expanding)
                        const dirLevel = level;
                        const childLevel = level + 1;
                        let next = el.nextElementSibling;
                        while (next && parseInt(next.getAttribute('data-tree-level') || 0) > dirLevel) {
                            if (isCollapsed) {
                                next.classList.add('hidden-by-parent');
                            } else if (parseInt(next.getAttribute('data-tree-level') || 0) === childLevel) {
                                // Only show direct children when expanding
                                next.classList.remove('hidden-by-parent');
                            }
                            next = next.nextElementSibling;
                        }
                    };
                    el.appendChild(toggle);
                    
                    // Content
                    const content = document.createElement('span');
                    content.className = 'tree-item-content';
                    const icon = document.createElement('span');
                    icon.innerHTML = Icons.folder;
                    icon.style.display = 'inline-flex';
                    const text = document.createElement('span');
                    text.textContent = name;
                    content.appendChild(icon);
                    content.appendChild(text);
                    el.appendChild(content);
                    
                    parentEl.appendChild(el);
                    return parentEl;
                },
                createSystemFile(name, parentEl, level) {
                    const el = document.createElement('div');
                    el.className = 'tree-item is-file';
                    el.setAttribute('data-tree-name', name);
                    el.setAttribute('data-tree-level', level);
                    el.setAttribute('data-tree-type', 'file');
                    el.style.paddingLeft = `${(level * 10) + 32}px`;
                    
                    // Content
                    const content = document.createElement('span');
                    content.className = 'tree-item-content';
                    content.style.cursor = 'pointer';
                    const icon = document.createElement('span');
                    icon.innerHTML = Icons.file;
                    icon.style.display = 'inline-flex';
                    const text = document.createElement('span');
                    text.textContent = name;
                    content.appendChild(icon);
                    content.appendChild(text);
                    el.appendChild(content);
                    
                    content.onclick = async () => this.loadFile(name);
                    parentEl.appendChild(el);
                },
                async loadFile(filename) {
                    if (this.loadedFiles.has(filename)) {
                        const existing = Store.state.buffers.find(b => b.name === filename && b.kind === 'system');
                        if (existing) return Store.setActive(existing.id);
                    }
                    
                    try {
                        UI.toast(`Loading ${filename}...`);
                        
                        // Check if file was pre-cached from filesys/docs
                        let content = this.fileCache.get(filename);
                        if (!content) {
                            const response = await fetch(filename);
                            if (!response.ok) {
                                // File doesn't exist - create new empty file instead of error
                                content = '';
                                UI.toast(`Created new file: ${filename}`);
                            } else {
                                content = await response.text();
                            }
                        }
                        
                        this.fileCache.set(filename, content);
                        this.loadedFiles.add(filename);
                        
                        // Add to buffers as system file (editable)
                        const existing = Store.state.buffers.find(b => b.name === filename);
                        if (existing) {
                            Store.setActive(existing.id);
                        } else {
                            Store.addBuffer({ id: 'sys' + Date.now(), name: filename, content, handle: null, kind: 'system', dirty: false, readonly: false });
                        }
                    } catch (e) {
                        UI.toast(`Error loading ${filename}: ${e.message}`);
                        console.error('Load failed:', e);
                    }
                },
                async lazyLoadFile(filename) {
                    // Try to load file if referenced from markdown links
                    return this.loadFile(filename);
                }
            };

            // Configure marked for custom link rendering
            // Icon definitions - centralized for easy modification

            const MarkedConfig = {
                init() {
                    try {
                        const renderer = new marked.Renderer();
                        renderer.link = (token) => {
                            const href = token.href;
                            // Check if this is an internal file link (no protocol or relative path)
                            const isInternal = !href.startsWith('http://') && !href.startsWith('https://') && !href.startsWith('www.');
                            const dataAttr = isInternal ? ' data-aether-file="true"' : '';
                            return `<a href="${href}"${dataAttr}>${token.text}</a>`;
                        };
                        marked.use({ renderer });
                    } catch (e) {
                        console.warn('Could not configure marked:', e);
                    }
                }
            };

            const App = {
                async loadWelcome() {
                    // Always fetch latest version from workspace first
                    const workspaceWelcome = await this.getDefaultWelcome();
                    if (workspaceWelcome) {
                        // Update OPFS with the latest version
                        try {
                            if (Store.state.opfsRoot) {
                                const handle = await Store.state.opfsRoot.getFileHandle('welcome.md', { create: true });
                                const writable = await handle.createWritable();
                                await writable.write(workspaceWelcome);
                                await writable.close();
                            }
                        } catch (e) {
                            console.warn('Could not update welcome.md in OPFS:', e);
                        }
                        return workspaceWelcome;
                    }
                    
                    // Fallback: load from OPFS if workspace unavailable
                    try {
                        if (!Store.state.opfsRoot) return null;
                        const handle = await Store.state.opfsRoot.getFileHandle('welcome.md', { create: false });
                        const file = await handle.getFile();
                        return await file.text();
                    } catch (e) {
                        console.warn('Failed to load welcome from OPFS:', e);
                        return "# Welcome to Aether\n\nA powerful, minimal code editor for the web.";
                    }
                },
                async getDefaultWelcome() {
                    // Fetch welcome.md from workspace with cache-busting
                    try {
                        const response = await fetch('welcome.md?t=' + Date.now(), {
                            cache: 'no-store',
                            headers: { 'Cache-Control': 'no-cache' }
                        });
                        if (response.ok) return await response.text();
                    } catch (e) {
                        console.warn('Could not fetch welcome.md:', e);
                    }
                    // Fallback content if file can't be fetched
                    return "# Welcome to Aether\n\nA powerful, minimal code editor for the web.\n\nOpen welcome.md to see documentation and examples.";
                },
                async init() {
                    await DB.init();
                    Editor.init();
                    await Config.init();
                    await FileSys.initOPFS();
                    Resizer.init();
                    Dragger.init();
                    MarkedConfig.init();
                    UI.initIconButtons();
                    await SystemFS.init();

                    const rootHandle = await DB.get('handles', 'rootDir');
                    if (rootHandle) FileSys.restoreRoot(rootHandle);

                    const tabScroll = document.getElementById('tabs-scroll');
                    tabScroll.addEventListener('wheel', (e) => {
                        if (e.deltaY !== 0) {
                            e.preventDefault();
                            tabScroll.scrollLeft += e.deltaY;
                        }
                    }, { passive: false });
                    
                    // Run initialization script from OPFS if available
                    try { await Script.runInitScript(); } catch (e) { /* ignore */ }

                    const savedEntries = await DB.getAll('session');
                    const meta = (savedEntries || []).find(e => e && e.id === 'meta');
                    const savedBuffers = (savedEntries || []).filter(e => e && e.id && e.id !== 'meta');

                    if (typeof meta !== 'undefined' && meta) {
                        if (typeof meta.consoleCollapsed !== 'undefined') Store.state.consoleCollapsed = !!meta.consoleCollapsed;
                        if (typeof meta.outlineCollapsed !== 'undefined') Store.state.outlineCollapsed = meta.outlineCollapsed || {};
                    }

                    if (savedBuffers.length) {
                        savedBuffers.forEach(b => Store.addBuffer(b));
                        const active = savedBuffers.find(b => b.active);
                        if (active) Store.setActive(active.id); else Store.setActive(savedBuffers[0].id);
                    } else {
                        // Load welcome.md from OPFS or use default
                        const welcomeText = await this.loadWelcome();
                        this.openBuffer('welcome.md', welcomeText, null, 'memory');
                        Store.state.buffers[0].dirty = false;
                        UI.renderTabs();
                    }

                    document.body.addEventListener('dragover', e => { e.preventDefault(); document.body.classList.add('drag-over'); });
                    document.body.addEventListener('dragleave', e => { if (e.relatedTarget === null) document.body.classList.remove('drag-over'); });
                    document.body.addEventListener('drop', async e => {
                        e.preventDefault(); document.body.classList.remove('drag-over');
                        for (const item of e.dataTransfer.items) {
                            if (item.kind === 'file') {
                                const file = item.getAsFile();
                                this.openBuffer(file.name, await file.text(), null, 'memory');
                            }
                        }
                    });

                    // Global shortcuts
                    document.addEventListener('keydown', (e) => {
                        if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'o') {
                            e.preventDefault();
                            Commands.trigger('openFile');
                        }
                        // Alt+Left for back
                        if (e.altKey && e.key === 'ArrowLeft') {
                            e.preventDefault();
                            App.goBack();
                        }
                        // Alt+Right for forward
                        if (e.altKey && e.key === 'ArrowRight') {
                            e.preventDefault();
                            App.goForward();
                        }
                    });

                    new ResizeObserver(() => Editor.instance.resize()).observe(document.querySelector('main'));

                    // Outline filter input debounce
                    try {
                        const of = document.getElementById('outline-filter');
                        if (of) {
                            let ot = null;
                            of.addEventListener('input', (e) => { clearTimeout(ot); ot = setTimeout(() => Symbols.parse(), 220); });
                            of.addEventListener('keydown', (e) => { if (e.key === 'Escape') { of.value = ''; Symbols.parse(); } });
                        }
                    } catch (e) {}

                    // Restore console collapsed state if present
                    try {
                        const pane = document.getElementById('console-pane');
                        const btn = document.getElementById('console-toggle-btn');
                        if (pane && Store.state.consoleCollapsed) pane.classList.add('collapsed');
                        if (btn) {
                            const collapsed = pane && pane.classList.contains('collapsed');
                            btn.innerHTML = collapsed ? Icons.chevronDown : Icons.chevronRight;
                        }
                    } catch (e) {}
                },
                openBuffer(name, content, handle, kind) {
                    const existing = Store.state.buffers.find(b => b.name === name);
                    if (existing) return Store.setActive(existing.id);
                    Store.addBuffer({ id: 'b' + Date.now(), name, content, handle, kind, dirty: false });
                },
                updateStats() {
                    if (!Editor.instance) return;
                    const pos = Editor.instance.getCursorPosition();
                    document.getElementById('stat-pos').innerText = `${pos.row + 1}:${pos.column + 1}`;
                    const buf = Store.activeBuffer;
                    if (buf) {
                        document.getElementById('stat-file').innerText = buf.name;
                        document.getElementById('stat-lang').innerText = buf.name.split('.').pop().toUpperCase();
                    }
                },
                goBack() {
                    if (Store.state.navIndex > 0) {
                        Store.state.navIndex--;
                        const targetId = Store.state.navHistory[Store.state.navIndex];
                        if (targetId) {
                            Store.state.activeId = targetId;
                            UI.renderTabs();
                            const buf = Store.activeBuffer;
                            if (buf) {
                                Editor.load(buf.content, buf.name);
                                document.getElementById('bc-filename').innerText = buf.name;
                            }
                            this.updateNavButtons();
                            this.debouncePreview(true);
                        }
                    }
                },
                goForward() {
                    if (Store.state.navIndex < Store.state.navHistory.length - 1) {
                        Store.state.navIndex++;
                        const targetId = Store.state.navHistory[Store.state.navIndex];
                        if (targetId) {
                            Store.state.activeId = targetId;
                            UI.renderTabs();
                            const buf = Store.activeBuffer;
                            if (buf) {
                                Editor.load(buf.content, buf.name);
                                document.getElementById('bc-filename').innerText = buf.name;
                            }
                            this.updateNavButtons();
                            this.debouncePreview(true);
                        }
                    }
                },
                updateNavButtons() {
                    const backBtn = document.getElementById('nav-back-btn');
                    const forwardBtn = document.getElementById('nav-forward-btn');
                    if (backBtn) backBtn.disabled = Store.state.navIndex <= 0;
                    if (forwardBtn) forwardBtn.disabled = Store.state.navIndex >= Store.state.navHistory.length - 1;
                },
                debouncePreview(immediate) {
                    if (!Store.state.previewMode) return;
                    clearTimeout(this.pvTimer);
                    const run = () => {
                        const buf = Store.activeBuffer; if (!buf) return;
                        const f = document.getElementById('preview-frame');
                        const ext = buf.name.split('.').pop().toLowerCase();
                        const styles = getComputedStyle(document.body);
                        const baseCss = `body{background:${styles.getPropertyValue('--bg')};color:${styles.getPropertyValue('--text')};font-family:sans-serif;padding:20px;line-height:1.6;}a{color:${styles.getPropertyValue('--accent')}}pre{background:rgba(0,0,0,0.2);padding:10px;border-radius:4px;overflow:auto}code{font-family:'JetBrains Mono',monospace;font-size:0.9em}blockquote{border-left:3px solid ${styles.getPropertyValue('--accent')};padding-left:1em;color:${styles.getPropertyValue('--text-dim')}}`;
                        let html = "";
                        if (ext === 'md') html = `<style>${baseCss}</style>` + marked.parse(buf.content);
                        else if (ext === 'html') html = buf.content;
                        else html = `<style>${baseCss}</style><pre>${buf.content.replace(/</g, '&lt;')}</pre>`;

                            // Use a persistent preview shell and postMessage updates to avoid flashing
                            const shell = `<!doctype html><html><head><meta charset="utf-8"></head><body></body><script>(function(){const _log=console.log,_err=console.error,_warn=console.warn,_info=console.info;console.log=(...args)=>{try{parent.postMessage({type:'console',method:'log',args},'*')}catch(e){};_log.apply(console,args)};console.error=(...args)=>{try{parent.postMessage({type:'console',method:'error',args},'*')}catch(e){};_err.apply(console,args)};console.warn=(...args)=>{try{parent.postMessage({type:'console',method:'warn',args},'*')}catch(e){};_warn.apply(console,args)};console.info=(...args)=>{try{parent.postMessage({type:'console',method:'info',args},'*')}catch(e){};_info.apply(console,args)};window.addEventListener('error',function(ev){try{parent.postMessage({type:'console',method:'error',args:['Uncaught Error: '+(ev.message||ev.error||ev.filename||ev.lineno)]},'*')}catch(e){}});function attachLinkHandlers(){const links=document.querySelectorAll('a[data-aether-file]');links.forEach(link=>{link.addEventListener('click',function(e){e.preventDefault();const filename=this.href.split('/').pop()||this.href;parent.postMessage({type:'aether-open-file',filename},'*');});});}window.addEventListener('message',function(e){if(!e.data) return; if(e.data.type==='update'){ document.body.innerHTML = e.data.html || ''; const scripts = Array.from(document.body.querySelectorAll('script')); scripts.forEach(s=>{ const ns = document.createElement('script'); if(s.src) ns.src = s.src; else ns.textContent = s.textContent; document.head.appendChild(ns); s.parentNode.removeChild(s); }); attachLinkHandlers(); }});setTimeout(attachLinkHandlers,100);})();<\/script></html>`;

                            const htmlContent = `<style>${baseCss}</style>` + (ext === 'md' ? marked.parse(buf.content) : (ext === 'html' ? buf.content : `<pre>${buf.content.replace(/</g, '&lt;')}</pre>`));

                            // If the shell isn't loaded yet, set it and post the content after load
                            if (!f.dataset.shellReady) {
                                f.onload = () => {
                                    try { f.contentWindow.postMessage({ type: 'update', html: htmlContent }, '*'); } catch (e) {}
                                    f.dataset.shellReady = '1';
                                    f.onload = null;
                                };
                                f.srcdoc = shell;
                            } else {
                                try { f.contentWindow.postMessage({ type: 'update', html: htmlContent }, '*'); } catch (e) {}
                            }
                    };
                    if (immediate) run(); else this.pvTimer = setTimeout(run, 500);
                },
                debounceSaveSession() {
                    clearTimeout(this.saveTimer);
                    this.saveTimer = setTimeout(() => this.saveSession(), 1000); // 1s debounce
                },
                toggleSidebar(side) {
                    document.getElementById(`sidebar-${side}`).classList.toggle('collapsed');
                    setTimeout(() => Editor.instance.resize(), 250);
                },
                runActiveJS() {
                    const buf = Store.activeBuffer;
                    if (!buf) return UI.toast('No active buffer');
                    const ext = buf.name.split('.').pop().toLowerCase();
                    if (ext !== 'js') return UI.toast('Run is for .js files only');

                    // Ensure preview visible
                    Store.state.previewMode = true;
                    document.body.classList.add('preview-active');

                    const styles = getComputedStyle(document.body);
                    const baseCss = `body{background:${styles.getPropertyValue('--bg')};color:${styles.getPropertyValue('--text')};font-family:sans-serif;padding:20px;line-height:1.6;}a{color:${styles.getPropertyValue('--accent')}}pre{background:rgba(0,0,0,0.2);padding:10px;border-radius:4px;overflow:auto}code{font-family:'JetBrains Mono',monospace;font-size:0.9em}`;

                    // Wrap code in async IIFE to support top-level await
                    // Also inject Aether API via postMessage bridge
                    const wrappedCode = `(async () => {
                        // Bridge to parent's Aether API
                        const Aether = {
                            log: (msg) => parent.postMessage({type:'aether-call',method:'log',msg},'*'),
                            warn: (msg) => parent.postMessage({type:'aether-call',method:'warn',msg},'*'),
                            error: (msg) => parent.postMessage({type:'aether-call',method:'error',msg},'*'),
                            toast: (msg, duration) => parent.postMessage({type:'aether-call',method:'toast',msg,duration},'*'),
                            openFile: (name, content) => parent.postMessage({type:'aether-call',method:'openFile',name,content},'*'),
                            newFile: (name, content) => parent.postMessage({type:'aether-call',method:'newFile',name,content},'*'),
                            getConfig: () => 'Use Script API instead',
                            setConfig: (k,v) => parent.postMessage({type:'aether-call',method:'setConfig',k,v},'*'),
                            updateTheme: (name) => parent.postMessage({type:'aether-call',method:'updateTheme',name},'*'),
                            updateZoom: (delta) => parent.postMessage({type:'aether-call',method:'updateZoom',delta},'*'),
                        };
${buf.content}
                    })();`;

                    const safeCode = wrappedCode.replace(/<\/script>/g, '<\\/script>');

                    const htmlContent = `<style>${baseCss}</style><script>${safeCode}<\/script>`;
                    const f = document.getElementById('preview-frame');

                    // Shell with postMessage handler to relay Aether calls
                    const shell = `<!doctype html><html><head><meta charset="utf-8"></head><body></body><script>(function(){const _log=console.log,_err=console.error,_warn=console.warn,_info=console.info;console.log=(...args)=>{try{parent.postMessage({type:'console',method:'log',args},'*')}catch(e){};_log.apply(console,args)};console.error=(...args)=>{try{parent.postMessage({type:'console',method:'error',args},'*')}catch(e){};_err.apply(console,args)};console.warn=(...args)=>{try{parent.postMessage({type:'console',method:'warn',args},'*')}catch(e){};_warn.apply(console,args)};console.info=(...args)=>{try{parent.postMessage({type:'console',method:'info',args},'*')}catch(e){};_info.apply(console,args)};window.addEventListener('error',function(ev){try{parent.postMessage({type:'console',method:'error',args:['Uncaught Error: '+(ev.message||ev.error||ev.filename||ev.lineno)]},'*')}catch(e){}});window.addEventListener('message',function(e){if(!e.data) return; if(e.data.type==='update'){ document.body.innerHTML = e.data.html || ''; const scripts = Array.from(document.body.querySelectorAll('script')); scripts.forEach(s=>{ const ns = document.createElement('script'); if(s.src) ns.src = s.src; else ns.textContent = s.textContent; document.head.appendChild(ns); s.parentNode.removeChild(s); }); }});})();<\/script></html>`;

                    if (!f.dataset.shellReady) {
                        f.onload = () => {
                            try { f.contentWindow.postMessage({ type: 'update', html: htmlContent }, '*'); } catch (e) {}
                            f.dataset.shellReady = '1';
                            f.onload = null;
                        };
                        f.srcdoc = shell;
                    } else {
                        try { f.contentWindow.postMessage({ type: 'update', html: htmlContent }, '*'); } catch (e) {}
                    }

                    setTimeout(() => Editor.instance.resize(), 200);
                },
                async saveSession() {
                    await DB.clear('session');
                    for (const b of Store.state.buffers) {
                        if (b.kind === 'config') continue;
                        await DB.set('session', null, {
                            id: b.id, name: b.name, content: b.content,
                            handle: b.handle, kind: b.kind, dirty: b.dirty,
                            active: b.id === Store.state.activeId
                        });
                    }
                    // persist UI meta (console collapsed state, etc.)
                    try {
                        await DB.set('session', null, { id: 'meta', consoleCollapsed: !!Store.state.consoleCollapsed, outlineCollapsed: Store.state.outlineCollapsed || {} });
                    } catch (e) { /* ignore persistence errors */ }
                },
                async saveBuffer(b) {
                    if (!b || b.kind === 'config') return;

                    // Recalculate 'active' status based on current Store state
                    // This prevents overwriting the active flag incorrectly if the user switched tabs quickly
                    const isActive = b.id === Store.state.activeId;

                    await DB.set('session', null, {
                        id: b.id,
                        name: b.name,
                        content: b.content,
                        handle: b.handle,
                        kind: b.kind,
                        dirty: b.dirty,
                        active: isActive
                    });
                },

                // Debounce specifically for the single buffer
                debounceSaveBuffer(b) {
                    clearTimeout(this.saveBufTimer);
                    this.saveBufTimer = setTimeout(() => {
                        // Safety check: Ensure buffer wasn't closed while timer was running
                        if (Store.state.buffers.find(x => x.id === b.id)) {
                            this.saveBuffer(b);
                        }
                    }, 1000); // 1 second debounce
                },
            };

            const UI = {
                renderTabs() {
                    const con = document.getElementById('tabs-scroll'); con.innerHTML = '';
                    Store.state.buffers.forEach(b => {
                        const el = document.createElement('div');
                        el.className = `tab ${b.id === Store.state.activeId ? 'active' : ''} ${b.dirty ? 'dirty' : ''}`;
                        const closeBtn = document.createElement('div');
                        closeBtn.className = 'tab-close';
                        closeBtn.innerHTML = Icons.close;
                        closeBtn.onclick = (e) => { e.stopPropagation(); Store.closeBuffer(b.id); };
                        const nameSpan = document.createElement('span');
                        nameSpan.textContent = b.name;
                        const dotSpan = document.createElement('span');
                        dotSpan.className = 'unsaved-dot';
                        el.appendChild(nameSpan);
                        el.appendChild(dotSpan);
                        el.appendChild(closeBtn);
                        el.onclick = () => Store.setActive(b.id);
                        con.appendChild(el);
                        if (b.id === Store.state.activeId) el.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                    });
                },
                toast(msg) { const t = document.getElementById('toast'); document.getElementById('toast-msg').innerText = msg; t.classList.add('visible'); clearTimeout(this.toastTimer); this.toastTimer = setTimeout(() => t.classList.remove('visible'), 2500); },
                clearConsole() { const logBox = document.getElementById('console-logs'); if (logBox) { logBox.innerHTML = ''; this.toast('Console cleared'); } },
                updateConsoleHeader() {
                    const runBtn = document.getElementById('console-run-btn');
                    if (!runBtn) return;
                    const buf = Store.activeBuffer;
                    const ext = buf && buf.name ? buf.name.split('.').pop().toLowerCase() : '';
                    runBtn.hidden = ext !== 'js';
                }
                ,
                toggleConsole() {
                    const pane = document.getElementById('console-pane');
                    const btn = document.getElementById('console-toggle-btn');
                    if (!pane || !btn) return;
                    pane.classList.toggle('collapsed');
                    const collapsed = pane.classList.contains('collapsed');
                    Store.state.consoleCollapsed = collapsed;
                    if (collapsed) {
                        btn.innerHTML = Icons.chevronDown;
                    } else {
                        btn.innerHTML = Icons.chevronRight;
                    }
                },
                initIconButtons() {
                    // Replace text icons in header buttons with SVG icons from Icons.js
                    const buttons = [
                        { selector: 'button[onclick="TreeSearch.collapseAll(\'file-tree\')"]', icon: 'chevronDown' },
                        { selector: 'button[onclick="FileSys.createWorkspaceDir()"]', icon: 'folder' },
                        { selector: 'button[onclick="FileSys.openFolder()"]', icon: 'menu' },
                        { selector: 'button[onclick="TreeSearch.collapseAll(\'opfs-tree\')"]', icon: 'chevronDown' },
                        { selector: 'button[onclick="FileSys.createOPFSDir()"]', icon: 'folder' },
                        { selector: 'button[onclick="FileSys.createOPFSFile()"]', icon: 'plus' }
                    ];
                    
                    buttons.forEach(({ selector, icon }) => {
                        const btn = document.querySelector(selector);
                        if (btn && Icons && Icons[icon]) {
                            btn.innerHTML = Icons[icon];
                        }
                    });
                }
            };

            const Commands = {
                list: typeof AETHER_COMMANDS !== 'undefined' ? AETHER_COMMANDS : [],
                trigger(id) { const c = this.list.find(c => c.id === id); if (c) c.fn(); },
                showPalette() {
                    const mask = document.getElementById('palette-mask');
                    const list = document.getElementById('cmd-list');
                    const input = document.getElementById('cmd-input');

                    const render = (filter = '') => {
                        list.innerHTML = '';
                        const terms = filter.toLowerCase();
                        this.list.filter(c => c.name.toLowerCase().includes(terms)).forEach((cmd, idx) => {
                            const el = document.createElement('div'); el.className = 'cmd-item';
                            if (idx === 0) el.classList.add('selected');
                            el.innerHTML = `<span>${cmd.name}</span><span class="cmd-shortcut">${cmd.hint}</span>`;
                            el.onclick = () => { cmd.fn(); this.hidePalette(); };
                            list.appendChild(el);
                        });
                    };

                    mask.style.display = 'flex';
                    input.value = '';
                    input.focus();
                    render();

                    input.oninput = (e) => render(e.target.value);
                    input.onkeydown = (e) => {
                        if (e.key === 'Escape') this.hidePalette();
                        if (e.key === 'Enter') {
                            const first = list.querySelector('.cmd-item');
                            if (first) first.click();
                        }
                    };
                },
                hidePalette() { document.getElementById('palette-mask').style.display = 'none'; Editor.instance.focus(); }
            };

            const Prompt = {
                open(msg, def, cb) {
                    document.getElementById('prompt-mask').style.display = 'flex'; document.getElementById('prompt-msg').innerText = msg;
                    const inp = document.getElementById('prompt-input'); inp.value = def; inp.focus(); inp.select();
                    const sub = () => { if (inp.value) cb(inp.value); this.close(); };
                    document.getElementById('prompt-ok').onclick = sub; inp.onkeydown = (e) => { if (e.key === 'Enter') sub(); if (e.key === 'Escape') this.close(); };
                },
                close() { document.getElementById('prompt-mask').style.display = 'none'; Editor.instance.focus(); }
            };

            const Confirm = {
                open(title, msg, onYes) {
                    document.getElementById('confirm-mask').style.display = 'flex'; document.getElementById('confirm-title').innerText = title;
                    document.getElementById('confirm-msg').innerText = msg; document.getElementById('confirm-ok').onclick = () => { onYes(); this.close(); };
                    document.querySelector('#confirm-mask .btn').focus();
                },
                close() { document.getElementById('confirm-mask').style.display = 'none'; Editor.instance.focus(); }
            };

            const Resizer = {
                init() {
                    // Split Resizer
                    const r = document.getElementById('resizer'); const p = document.getElementById('preview-pane'); let isResizing = false;
                    r.onmousedown = (e) => {
                        if (document.getElementById('editor-split').classList.contains('mode-float')) return;
                        isResizing = true; r.classList.add('active'); document.body.classList.add('resizing'); e.preventDefault();
                    };

                    // Float Resizer
                    const fr = document.getElementById('float-resizer');
                    let isFloatResizing = false;
                    let startX, startY, startW, startH;

                    fr.onmousedown = (e) => {
                        isFloatResizing = true;
                        startX = e.clientX; startY = e.clientY;
                        startW = p.offsetWidth; startH = p.offsetHeight;
                        e.stopPropagation(); e.preventDefault();
                    };

                    document.addEventListener('mousemove', (e) => {
                        if (isResizing) {
                            const w = document.getElementById('editor-split').offsetWidth;
                            const pW = 100 - ((e.clientX - document.getElementById('sidebar-left').offsetWidth) / w * 100);
                            if (pW > 10 && pW < 90) { p.style.width = pW + '%'; Editor.instance.resize(); }
                        }
                        if (isFloatResizing) {
                            p.style.width = (startW + (e.clientX - startX)) + 'px';
                            p.style.height = (startH + (e.clientY - startY)) + 'px';
                        }
                    });

                    document.addEventListener('mouseup', () => {
                        if (isResizing) { isResizing = false; r.classList.remove('active'); document.body.classList.remove('resizing'); Editor.instance.resize(); }
                        if (isFloatResizing) { isFloatResizing = false; }
                    });
                }
            };

            const Dragger = {
                init() {
                    const header = document.getElementById('preview-header');
                    const pane = document.getElementById('preview-pane');
                    let isDragging = false;
                    let startX, startY, initialLeft, initialTop;

                    header.onmousedown = (e) => {
                        if (!document.getElementById('editor-split').classList.contains('mode-float')) return;
                        isDragging = true;
                        document.body.classList.add('dragging-preview');
                        startX = e.clientX;
                        startY = e.clientY;

                        const rect = pane.getBoundingClientRect();
                        const parentRect = document.getElementById('editor-split').getBoundingClientRect();

                        initialLeft = rect.left - parentRect.left;
                        initialTop = rect.top - parentRect.top;

                        pane.style.right = 'auto';
                        pane.style.left = initialLeft + 'px';
                        pane.style.top = initialTop + 'px';
                    };

                    document.addEventListener('mousemove', (e) => {
                        if (!isDragging) return;
                        const dx = e.clientX - startX;
                        const dy = e.clientY - startY;
                        pane.style.left = (initialLeft + dx) + 'px';
                        pane.style.top = (initialTop + dy) + 'px';
                    });

                    document.addEventListener('mouseup', () => {
                        if (isDragging) {
                            isDragging = false;
                            document.body.classList.remove('dragging-preview');
                        }
                    });
                }
            };

            window.onload = () => {
                App.init();
                // Populate icons from Icons object
                document.querySelectorAll('[data-icon]').forEach(btn => {
                    const iconName = btn.getAttribute('data-icon');
                    if (Icons[iconName]) {
                        btn.innerHTML = Icons[iconName];
                    }
                });
                // Register service worker for PWA functionality
                if ('serviceWorker' in navigator) {
                    navigator.serviceWorker.register('/sw.js').catch(e => console.log('SW registration failed:', e));
                }
            };
            window.addEventListener('message', (event) => {
                if (!event.data) return;
                const previewFrame = document.getElementById('preview-frame');
                if (!previewFrame || event.source !== previewFrame.contentWindow) return;

                // Handle file opening requests from markdown preview
                if (event.data.type === 'aether-open-file') {
                    const filename = event.data.filename;
                    if (filename) {
                        // Try to find existing buffer first
                        const existing = Store.state.buffers.find(b => b.name === filename);
                        if (existing) {
                            Store.setActive(existing.id);
                            App.debouncePreview(true);
                        } else {
                            // Try to lazy load from system filesystem
                            SystemFS.lazyLoadFile(filename).then(() => {
                                const loaded = Store.state.buffers.find(b => b.name === filename);
                                if (loaded) {
                                    Store.setActive(loaded.id);
                                    App.debouncePreview(true);
                                }
                            }).catch(() => {
                                UI.toast('File not found: ' + filename);
                            });
                        }
                    }
                    return;
                }

                // Handle Aether API calls from preview frame
                if (event.data.type === 'aether-call') {
                    const method = event.data.method;
                    try {
                        if (method === 'log') console.log(event.data.msg);
                        else if (method === 'warn') console.warn(event.data.msg);
                        else if (method === 'error') console.error(event.data.msg);
                        else if (method === 'toast') UI.toast(event.data.msg, event.data.duration);
                        else if (method === 'openFile') Script.context.openFile(event.data.name, event.data.content);
                        else if (method === 'newFile') Script.context.newFile(event.data.name, event.data.content);
                        else if (method === 'setConfig') Script.context.setConfig(event.data.k, event.data.v);
                        else if (method === 'updateTheme') Script.context.updateTheme(event.data.name);
                        else if (method === 'updateZoom') Script.context.updateZoom(event.data.delta);
                    } catch (e) { console.error('Aether API error:', e); }
                    return;
                }

                // Handle console logs (existing logic)
                if (event.data.type !== 'console') return;

                const logBox = document.getElementById('console-logs');
                const entry = document.createElement('div');

                const color = event.data.method === 'error' ? 'var(--log-error)' :
                    event.data.method === 'warn' ? 'var(--log-warn)' :
                    event.data.method === 'info' ? 'var(--log-info)' : 'var(--text)';

                entry.style.color = color;
                entry.style.borderBottom = '1px solid rgba(255,255,255,0.05)';
                entry.style.padding = '2px 0';

                const text = (event.data.args || []).map(a => {
                    try {
                        if (a && a.stack) return a.stack;
                        if (typeof a === 'object') return JSON.stringify(a);
                        return String(a);
                    } catch (e) { return String(a); }
                }).join(' ');

                entry.innerText = `> ${text}`;

                logBox.appendChild(entry);
                const MAX_LOGS = 200;
                while (logBox.children.length > MAX_LOGS) logBox.removeChild(logBox.firstChild);
                logBox.scrollTop = logBox.scrollHeight; // Auto-scroll to bottom
            });
        </script>
    </body>

    </html>